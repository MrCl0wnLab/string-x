"""
Sistema de upgrade do String-X usando Git.

Este m√≥dulo gerencia atualiza√ß√µes autom√°ticas do String-X,
permitindo ao usu√°rio confirmar antes de aplicar as mudan√ßas.
"""

# Biblioteca padr√£o
import os
import sys
import subprocess
import re
from pathlib import Path
from typing import Tuple, List, Optional

# M√≥dulos locais
from stringx.core.style_cli import StyleCli

class UpgradeManager:
    """
    Gerenciador de atualiza√ß√µes do String-X.
    
    Esta classe √© respons√°vel por verificar e aplicar atualiza√ß√µes
    do c√≥digo-fonte usando Git, com suporte a confirma√ß√£o do usu√°rio.
    """
    
    def __init__(self):
        """Inicializa o gerenciador de atualiza√ß√µes."""
        self.cli = StyleCli()
        self.repo_url = "https://github.com/MrCl0wnLab/string-x.git"
    
    def _run_command(self, command: str) -> Tuple[bool, str, str]:
        """
        Executa um comando shell de forma segura.
        
        Args:
            command (str): Comando a ser executado
            
        Returns:
            tuple: (sucesso, stdout, stderr)
        """
        try:
            result = subprocess.run(command, shell=True, capture_output=True, text=True)
            return (result.returncode == 0, result.stdout, result.stderr)
        except Exception as e:
            return (False, "", str(e))
    
    def _ask_confirmation(self, message: str = "Continuar?") -> bool:
        """
        Solicita confirma√ß√£o do usu√°rio.
        
        Args:
            message (str): Mensagem a ser exibida
            
        Returns:
            bool: True se confirmado, False caso contr√°rio
        """
        try:
            response = input(f"\n{message} [N/y]: ").lower().strip()
            return response == 'y'
        except KeyboardInterrupt:
            print("\nOpera√ß√£o cancelada pelo usu√°rio.")
            return False
    
    def _is_git_repo(self) -> bool:
        """Verifica se est√° em um reposit√≥rio Git"""
        return Path('.git').exists()
    
    def _get_pending_commits(self) -> List[str]:
        """
        Obt√©m os commits pendentes para download.
        
        Returns:
            List[str]: Lista de commits pendentes formatados
        """
        if not self._is_git_repo():
            return []
        
        # Atualiza as refer√™ncias remotas
        self._run_command("git fetch origin main")
        
        # Obt√©m os commits entre HEAD local e origin/main
        success, stdout, _ = self._run_command("git log HEAD..origin/main --pretty=format:'%h - %s (%an, %ar)'")
        if success and stdout:
            commits = stdout.strip().split('\n')
            return [commit for commit in commits if commit]  # Remove linhas vazias
        return []
    
    def _format_commit_message(self, commit: str) -> str:
        """
        Formata uma mensagem de commit para exibi√ß√£o com destaque para tipos comuns.
        
        Args:
            commit (str): Mensagem de commit original
            
        Returns:
            str: Mensagem formatada com destaque
        """
        # Destacar tipos de commit comuns
        commit_types = {
            'feat': '[bright_green]FEATURE[/bright_green]',
            'fix': '[bright_red]FIX[/bright_red]',
            'docs': '[bright_blue]DOCS[/bright_blue]',
            'style': '[magenta]STYLE[/magenta]',
            'refactor': '[yellow]REFACTOR[/yellow]',
            'perf': '[bright_cyan]PERF[/bright_cyan]',
            'test': '[bright_magenta]TEST[/bright_magenta]',
            'chore': '[dim]CHORE[/dim]',
            'security': '[bright_red]SECURITY[/bright_red]'
        }
        
        # Tenta extrair o tipo do commit da mensagem
        match = re.search(r'([a-z0-9]{7}) - ((?:feat|fix|docs|style|refactor|perf|test|chore|security)(?:\([^)]+\))?:)?\s*(.*)', commit)
        if match:
            hash_commit, type_commit, message = match.groups()
            
            if type_commit:
                # Extrair apenas o tipo sem os par√™nteses
                commit_type = type_commit.split('(')[0].strip(':')
                if commit_type in commit_types:
                    return f"[cyan]{hash_commit}[/cyan] {commit_types[commit_type]} {message}"
                    
        # Se n√£o conseguiu extrair ou n√£o √© um tipo conhecido, retorna o original
        return f"[cyan]  ‚Ü≥[/cyan] {commit}"
    
    def upgrade(self) -> bool:
        """
        Executa o processo de upgrade usando Git com confirma√ß√£o do usu√°rio.
        
        Returns:
            bool: True se o upgrade foi bem-sucedido, False caso contr√°rio
        """
        try:
            self.cli.console.print("\n[bold cyan]‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó[/bold cyan]")
            self.cli.console.print("[bold cyan]‚ïë[/bold cyan]  [bold white]String-X Upgrade Manager[/bold white]  [bold cyan]‚ïë[/bold cyan]")
            self.cli.console.print("[bold cyan]‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù[/bold cyan]\n")
            
            self.cli.console.print("[blue]Verificando atualiza√ß√µes...[/blue]")
            
            if self._is_git_repo():
                # Projeto j√° √© um reposit√≥rio Git
                # Obter commits pendentes
                pending_commits = self._get_pending_commits()
                
                if not pending_commits:
                    self.cli.console.print("[green]Seu c√≥digo j√° est√° atualizado![/green]")
                    return True
                
                # Mostrar commits que ser√£o baixados
                num_commits = len(pending_commits)
                self.cli.console.print(f"[yellow]{num_commits} novo(s) commit(s) dispon√≠veis:[/yellow]")
                
                # Exibir commits formatados
                for commit in pending_commits:
                    self.cli.console.print(self._format_commit_message(commit))
                
                # Solicitar confirma√ß√£o do usu√°rio
                self.cli.console.print("\n[yellow]Arquivos modificados ser√£o preservados quando poss√≠vel.[/yellow]")
                if not self._ask_confirmation("Deseja atualizar para a √∫ltima vers√£o?"):
                    self.cli.console.print("[blue]Atualiza√ß√£o cancelada pelo usu√°rio.[/blue]")
                    return False
                
                self.cli.console.print("[blue]Atualizando reposit√≥rio Git...[/blue]")
                
                # Fazer stash das mudan√ßas locais (salva modifica√ß√µes locais)
                has_changes, _, _ = self._run_command("git diff-index --quiet HEAD -- || echo 'has-changes'")
                if has_changes:
                    self.cli.console.print("[yellow]Salvando suas modifica√ß√µes locais...[/yellow]")
                    self._run_command("git stash save 'Auto-stash before strx upgrade'")
                
                # Pull das atualiza√ß√µes
                success, _, stderr = self._run_command("git pull origin main")
                if success:
                    self.cli.console.print("[green]C√≥digo atualizado com sucesso![/green]")
                else:
                    self.cli.console.print("[yellow]Erro no git pull, tentando m√©todo alternativo...[/yellow]")
                    
                    if "local changes" in stderr:
                        # Conflito com altera√ß√µes locais
                        self.cli.console.print("[yellow]Conflito detectado com altera√ß√µes locais.[/yellow]")
                        
                        if self._ask_confirmation("For√ßar atualiza√ß√£o? (suas altera√ß√µes locais ser√£o perdidas)"):
                            self._run_command("git reset --hard origin/main")
                            self.cli.console.print("[green]C√≥digo atualizado for√ßadamente![/green]")
                        else:
                            self.cli.console.print("[blue]Atualiza√ß√£o cancelada para preservar altera√ß√µes locais.[/blue]")
                            return False
                    else:
                        # Outro tipo de erro, tentar reset
                        self._run_command("git reset --hard origin/main")
                
                # Restaurar mudan√ßas locais do stash se houver
                if has_changes:
                    self.cli.console.print("[yellow]Restaurando suas modifica√ß√µes locais...[/yellow]")
                    stash_result, _, _ = self._run_command("git stash pop")
                    if not stash_result:
                        self.cli.console.print("[yellow]Houve conflitos ao restaurar suas mudan√ßas.[/yellow]")
                        self.cli.console.print("[yellow]Suas altera√ß√µes foram preservadas no git stash.[/yellow]")
                
            else:
                # N√£o √© um repo Git, fazer clone
                self.cli.console.print("[blue]üì• N√£o √© um reposit√≥rio Git.[/blue]")
                self.cli.console.print("[yellow]Clone completo ser√° executado - todos os commits ser√£o baixados[/yellow]")
                
                # Solicitar confirma√ß√£o do usu√°rio
                if not self._ask_confirmation("Deseja baixar a vers√£o mais recente do String-X?"):
                    self.cli.console.print("[blue]Atualiza√ß√£o cancelada pelo usu√°rio.[/blue]")
                    return False
                
                # Backup dos arquivos importantes
                important_dirs = ["output", "config"]
                backup_created = False
                
                for dir_name in important_dirs:
                    if Path(dir_name).exists():
                        self.cli.console.print(f"[yellow]Fazendo backup da pasta '{dir_name}'...[/yellow]")
                        self._run_command(f"cp -r {dir_name} /tmp/strx_{dir_name}_backup")
                        backup_created = True
                
                # Clone do reposit√≥rio
                self.cli.console.print("[blue]üì• Clonando reposit√≥rio...[/blue]")
                success, _, _ = self._run_command(f"git clone {self.repo_url} /tmp/string-x-new")
                if success:
                    self.cli.console.print("[blue]üì¶ Aplicando atualiza√ß√£o...[/blue]")
                    
                    # Substituir arquivos
                    self._run_command("cp -r /tmp/string-x-new/* .")
                    self._run_command("rm -rf /tmp/string-x-new")
                    
                    # Restaurar backups
                    if backup_created:
                        self.cli.console.print("[yellow]Restaurando arquivos e configura√ß√µes...[/yellow]")
                        for dir_name in important_dirs:
                            if Path(f"/tmp/strx_{dir_name}_backup").exists():
                                self._run_command(f"cp -r /tmp/strx_{dir_name}_backup/* {dir_name}/")
                                self._run_command(f"rm -rf /tmp/strx_{dir_name}_backup")
                else:
                    self.cli.console.print("[red]‚ùå Erro no clone[/red]")
                    return False
            
            # Tornar o script execut√°vel
            os.chmod("strx", 0o755)
            
            # Perguntar se deve atualizar depend√™ncias
            if self._ask_confirmation("Deseja atualizar as depend√™ncias Python?"):
                self.cli.console.print("[blue]üì¶ Atualizando depend√™ncias...[/blue]")
                success, _, _ = self._run_command(f"{sys.executable} -m pip install -r requirements.txt")
                if success:
                    self.cli.console.print("[green]Depend√™ncias atualizadas com sucesso![/green]")
                else:
                    self.cli.console.print("[yellow]Erro ao atualizar depend√™ncias[/yellow]")
            
            self.cli.console.print("\n[green bold]String-X atualizado com sucesso![/green bold]")
            self.cli.console.print("[blue]üí° Reinicie o terminal para garantir as mudan√ßas[/blue]")
            return True
                
        except Exception as e:
            self.cli.console.print(f"[red]‚ùå Erro: {str(e)}[/red]")
            return False